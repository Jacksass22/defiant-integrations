
Introduction
Installation

Split Text
Blur Text
Circular Text
Text Type
New
Shiny Text
Text Pressure
Curved Loop
New
Fuzzy Text
Gradient Text
Text Trail
Falling Text
Text Cursor
Decrypted Text
True Focus
Scroll Float
Scroll Reveal
ASCII Text
Scramble Text
Rotating Text
Glitch Text
Scroll Velocity
Variable Proximity
Count Up

Animated Content
Fade Content
Pixel Transition
Glare Hover
Target Cursor
New
Magnet Lines
Click Spark
Magnet
Sticker Peel
New
Pixel Trail
Cubes
New
Metallic Paint
Noise
Shape Blur
Crosshair
Image Trail
Ribbons
Splash Cursor
Meta Balls
Blob Cursor
Star Border

Animated List
Scroll Stack
New
Magic Bento
New
Circular Gallery
Stack
Fluid Glass
Tilted Card
Masonry
Glass Surface
New
Chroma Grid
Folder
Model Viewer
Lanyard
Profile Card
Dock
Gooey Nav
Pixel Card
Carousel
Spotlight Card
Flying Posters
Card Swap
Infinite Scroll
Glass Icons
Decay Card
Flowing Menu
Elastic Slider
Counter
Infinite Menu
Rolling Gallery
Stepper
Bounce Cards

Dark Veil
New
Silk
Light Rays
New
Aurora
Particles
Beams
Lightning
Galaxy
New
Dither
Faulty Terminal
New
Ripple Grid
New
Dot Grid
Threads
Hyperspeed
Iridescence
Waves
Grid Distortion
Ballpit
Orb
Letter Glitch
Grid Motion
Squares
Liquid Chrome
Balatro
Blur Text
Preview
Code
CLI
Contribute
installation
npm i framer-motion
usage
import BlurText from "./BlurText";

const handleAnimationComplete = () => {
  console.log('Animation completed!');
};

<BlurText
  text="Isn't this so cool?!"
  delay={150}
  animateBy="words"
  direction="top"
  onAnimationComplete={handleAnimationComplete}
  className="text-2xl mb-8"
/>
code
Default

Tailwind

import { motion } from 'framer-motion';
import { useEffect, useRef, useState, useMemo } from 'react';

const buildKeyframes = (from, steps) => {
  const keys = new Set([
    ...Object.keys(from),
    ...steps.flatMap((s) => Object.keys(s)),
  ]);

  const keyframes = {};
  keys.forEach((k) => {
    keyframes[k] = [from[k], ...steps.map((s) => s[k])];
  });
  return keyframes;
};

const BlurText = ({
  text = '',
  delay = 200,
  className = '',
  animateBy = 'words',
  direction = 'top',
  threshold = 0.1,
  rootMargin = '0px',
  animationFrom,
  animationTo,
  easing = (t) => t,
  onAnimationComplete,
  stepDuration = 0.35,
}) => {
  const elements = animateBy === 'words' ? text.split(' ') : text.split('');
  const [inView, setInView] = useState(false);
  const ref = useRef(null);

  useEffect(() => {
    if (!ref.current) return;
    const observer = new IntersectionObserver(
      ([entry]) => {
        if (entry.isIntersecting) {
          setInView(true);
          observer.unobserve(ref.current);
        }
      },
      { threshold, rootMargin }
    );
    observer.observe(ref.current);
    return () => observer.disconnect();
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, [threshold, rootMargin]);

  const defaultFrom = useMemo(
    () =>
      direction === 'top'
        ? { filter: 'blur(10px)', opacity: 0, y: -50 }
        : { filter: 'blur(10px)', opacity: 0, y: 50 },
    [direction]
  );

  const defaultTo = useMemo(
    () => [
      {
        filter: 'blur(5px)',
        opacity: 0.5,
        y: direction === 'top' ? 5 : -5,
      },
      { filter: 'blur(0px)', opacity: 1, y: 0 },
    ],
    [direction]
  );

  const fromSnapshot = animationFrom ?? defaultFrom;
  const toSnapshots = animationTo ?? defaultTo;

  const stepCount = toSnapshots.length + 1;
  const totalDuration = stepDuration * (stepCount - 1);
  const times = Array.from({ length: stepCount }, (_, i) =>
    stepCount === 1 ? 0 : i / (stepCount - 1)
  );

  return (
    <p
      ref={ref}
      className={className}
      style={{ display: 'flex', flexWrap: 'wrap' }}
    >
      {elements.map((segment, index) => {
        const animateKeyframes = buildKeyframes(fromSnapshot, toSnapshots);

        const spanTransition = {
          duration: totalDuration,
          times,
          delay: (index * delay) / 1000,
        };
        (spanTransition).ease = easing;

        return (
          <motion.span
            className="inline-block will-change-[transform,filter,opacity]"
            key={index}
            initial={fromSnapshot}
            animate={inView ? animateKeyframes : fromSnapshot}
            transition={spanTransition}
            onAnimationComplete={
              index === elements.length - 1 ? onAnimationComplete : undefined
            }
          >
            {segment === ' ' ? '\u00A0' : segment}
            {animateBy === 'words' && index < elements.length - 1 && '\u00A0'}
          </motion.span>
        );
      })}
    </p>
  );
};

export default BlurText;